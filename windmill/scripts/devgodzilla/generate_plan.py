"""
Generate Implementation Plan Script

Generates an implementation plan from a feature specification.

Args:
    project_path: Path to the project directory
    spec_path: Path to the feature specification (relative to project)
    tech_hints: Optional hints about technology choices

Returns:
    plan_path: Path to generated plan
    implementation_plan: Parsed plan content
"""

import os
from pathlib import Path
from datetime import datetime
import json

# Import DevGodzilla services if available
try:
    from devgodzilla.services import PlanningService
    from devgodzilla.db import get_database
    DEVGODZILLA_AVAILABLE = True
except ImportError:
    DEVGODZILLA_AVAILABLE = False


def main(
    project_path: str,
    spec_path: str,
    tech_hints: str = "",
) -> dict:
    """Generate an implementation plan from specification."""
    
    path = Path(project_path)
    
    # Resolve spec path
    if not os.path.isabs(spec_path):
        full_spec_path = path / spec_path
    else:
        full_spec_path = Path(spec_path)
    
    if not full_spec_path.exists():
        return {"error": f"Specification not found: {spec_path}"}
    
    # Read specification
    spec_content = full_spec_path.read_text()
    
    # Determine output directory (same as spec)
    spec_dir = full_spec_path.parent
    plan_path = spec_dir / "plan.md"
    
    # Generate plan using DevGodzilla if available
    if DEVGODZILLA_AVAILABLE:
        try:
            db = get_database()
            planning_service = PlanningService(db)
            result = planning_service.generate_plan(
                specification=spec_content,
                project_path=str(path),
                tech_hints=tech_hints,
            )
            plan_content = result.content if hasattr(result, 'content') else str(result)
        except Exception as e:
            plan_content = _generate_fallback_plan(spec_content, tech_hints, path)
    else:
        plan_content = _generate_fallback_plan(spec_content, tech_hints, path)
    
    # Write plan
    plan_path.write_text(plan_content)
    
    # Update context
    runtime_dir = spec_dir / "_runtime"
    context_path = runtime_dir / "context.json"
    if context_path.exists():
        context = json.loads(context_path.read_text())
    else:
        context = {}
    
    context["plan_generated_at"] = datetime.now().isoformat()
    context["tech_hints"] = tech_hints
    
    runtime_dir.mkdir(exist_ok=True)
    context_path.write_text(json.dumps(context, indent=2))
    
    return {
        "plan_path": str(plan_path),
        "implementation_plan": {
            "path": str(plan_path.relative_to(path)),
            "spec_path": spec_path,
        },
    }


def _generate_fallback_plan(spec_content: str, tech_hints: str, project_path: Path) -> str:
    """Generate a basic implementation plan without AI."""
    
    # Extract title from spec
    lines = spec_content.split('\n')
    title = "Feature"
    for line in lines:
        if line.startswith('# '):
            title = line[2:].replace("Feature Specification:", "").strip()
            break
    
    tech_section = ""
    if tech_hints:
        tech_section = f"""
## Technology Stack
{tech_hints}
"""
    else:
        tech_section = """
## Technology Stack
- Follow existing project conventions
- Use standard library where possible
"""
    
    return f"""# Implementation Plan: {title}

## Overview
This plan outlines the implementation approach for the feature described in the specification.

{tech_section}

## Components

### New Components
1. Core feature implementation
2. Unit tests
3. Integration tests

### Modified Components
1. Any existing components that need updates for integration

## Implementation Phases

### Phase 1: Setup
- Set up necessary project structure
- Add any new dependencies

### Phase 2: Core Implementation
- Implement main feature logic
- Follow existing code patterns

### Phase 3: Testing
- Write unit tests
- Write integration tests
- Ensure coverage meets project standards

### Phase 4: Documentation
- Update README if needed
- Add inline documentation
- Update API docs if applicable

## Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| Breaking changes | Maintain backward compatibility |
| Performance impact | Benchmark before/after |
| Test coverage gaps | Require 80%+ coverage |

## Dependencies
- Existing project dependencies
- No new external dependencies required (unless specified)

## Estimated Effort
- Setup: 1 hour
- Core Implementation: 2-4 hours
- Testing: 2-3 hours
- Documentation: 1 hour

---
*Generated by DevGodzilla SpecKit*
"""
