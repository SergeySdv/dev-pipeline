import os
import shutil
import sys
from pathlib import Path
from typing import Optional

from . import codex
from .logging import get_logger

log = get_logger(__name__)

# Map of target paths -> template paths (relative to repo root of this starter)
BASE_FILES = {
    "docs/deksdenflow.md": "docs/deksdenflow.md",
    "docs/ci.md": "docs/ci.md",
    "prompts/project-init.prompt.md": "prompts/project-init.prompt.md",
    "prompts/protocol-new.prompt.md": "prompts/protocol-new.prompt.md",
    "prompts/protocol-resume.prompt.md": "prompts/protocol-resume.prompt.md",
    "prompts/protocol-review-merge.prompt.md": "prompts/protocol-review-merge.prompt.md",
    "prompts/protocol-review-merge-resume.prompt.md": "prompts/protocol-review-merge-resume.prompt.md",
    "prompts/protocol-pipeline.prompt.md": "prompts/protocol-pipeline.prompt.md",
    "prompts/project-setup.prompt.md": "prompts/project-setup.prompt.md",
    "prompts/repo-discovery.prompt.md": "prompts/repo-discovery.prompt.md",
    "prompts/java-testing.prompt.md": "prompts/java-testing.prompt.md",
    "scripts/codex_ci_bootstrap.py": "scripts/codex_ci_bootstrap.py",
    "scripts/quality_orchestrator.py": "scripts/quality_orchestrator.py",
    "prompts/quality-validator.prompt.md": "prompts/quality-validator.prompt.md",
    "schemas/protocol-planning.schema.json": "schemas/protocol-planning.schema.json",
    "scripts/protocol_pipeline.py": "scripts/protocol_pipeline.py",
    ".github/workflows/ci.yml": ".github/workflows/ci.yml",
    ".gitlab-ci.yml": ".gitlab-ci.yml",
    "scripts/ci/bootstrap.sh": "scripts/ci/bootstrap.sh",
    "scripts/ci/lint.sh": "scripts/ci/lint.sh",
    "scripts/ci/typecheck.sh": "scripts/ci/typecheck.sh",
    "scripts/ci/test.sh": "scripts/ci/test.sh",
    "scripts/ci/build.sh": "scripts/ci/build.sh",
}

PLACEHOLDER = (
    "# Generated placeholder\n\n"
    "This file was generated by project_setup.py because no template was found. "
    "Please replace with the starter content from the DeksdenFlow_Ilyas_Edition_1.0 starter."
)


def ensure_git_repo(base_branch: str, init_if_needed: bool) -> Path:
    try:
        out = codex.run_process(["git", "rev-parse", "--show-toplevel"], capture_output=True, text=True)
        return Path(out.stdout.strip())
    except Exception:
        if not init_if_needed:
            log.error("git_repo_missing", extra={"init_if_needed": init_if_needed, "cwd": str(Path.cwd())})
            sys.exit(1)
        log.info("git_repo_init", extra={"base_branch": base_branch})
        codex.run_process(["git", "init", "-b", base_branch], capture_output=False, text=True)
        out = codex.run_process(["git", "rev-parse", "--show-toplevel"], capture_output=True, text=True)
        return Path(out.stdout.strip())


def ensure_remote_origin(repo_root: Path) -> None:
    try:
        codex.run_process(["git", "remote", "get-url", "origin"], cwd=repo_root, capture_output=True, text=True)
    except Exception:
        log.warning("git_origin_missing", extra={"repo_root": str(repo_root)})


def ensure_base_branch(repo_root: Path, base_branch: str) -> None:
    try:
        codex.run_process(
            ["git", "show-ref", "--verify", f"refs/heads/{base_branch}"],
            cwd=repo_root,
            capture_output=True,
            text=True,
        )
    except Exception:
        log.warning("base_branch_missing", extra={"repo_root": str(repo_root), "base_branch": base_branch})


def copy_if_missing(target: Path, source: Path) -> None:
    if target.exists():
        return
    target.parent.mkdir(parents=True, exist_ok=True)
    if source.is_file():
        shutil.copyfile(source, target)
        if source.stat().st_mode & 0o111:
            target.chmod(source.stat().st_mode)
        log.info("template_copied", extra={"target": str(target), "source": str(source)})
    else:
        target.write_text(PLACEHOLDER, encoding="utf-8")
        log.info("template_placeholder_created", extra={"target": str(target), "source": str(source)})


def make_executable(path: Path) -> None:
    try:
        mode = path.stat().st_mode
        path.chmod(mode | 0o111)
    except FileNotFoundError:
        pass


def ensure_assets(repo_root: Path) -> None:
    script_dir = Path(__file__).resolve().parent
    template_root = script_dir.parent
    for rel_target, rel_source in BASE_FILES.items():
        target = repo_root / rel_target
        source = template_root / rel_source
        copy_if_missing(target, source)
    for name in ["bootstrap.sh", "lint.sh", "typecheck.sh", "test.sh", "build.sh"]:
        make_executable(repo_root / "scripts" / "ci" / name)


def clone_repo(url: str, target_dir: Path) -> Path:
    if target_dir.exists():
        log.info("clone_target_exists", extra={"target_dir": str(target_dir)})
        return target_dir
    target_dir.parent.mkdir(parents=True, exist_ok=True)
    log.info("clone_repo", extra={"url": url, "target_dir": str(target_dir)})
    codex.run_process(["git", "clone", url, str(target_dir)], capture_output=False, text=True)
    return target_dir


def run_codex_discovery(
    repo_root: Path,
    model: str,
    prompt_file: Optional[Path] = None,
    sandbox: str = "workspace-write",
    skip_git_check: bool = True,
    strict: bool = False,
) -> None:
    """
    Run Codex discovery (repo analysis + CI suggestions) with the repo-discovery prompt.

    strict=False (default) matches the setup script behavior: if codex or the prompt
    is missing, print a warning and return. strict=True raises FileNotFoundError in
    those cases so CLIs can fail fast.
    """
    if shutil.which("codex") is None:
        msg = "codex CLI not found; skipping discovery."
        if strict:
            log.error("codex_cli_missing", extra={"repo_root": str(repo_root), "model": model})
            raise FileNotFoundError(msg)
        log.warning("codex_cli_missing", extra={"repo_root": str(repo_root), "model": model})
        return

    prompt_path = prompt_file if prompt_file else repo_root / "prompts" / "repo-discovery.prompt.md"
    if not prompt_path.is_file():
        msg = f"repo-discovery prompt not found at {prompt_path}; skipping discovery."
        if strict:
            log.error("discovery_prompt_missing", extra={"prompt_path": str(prompt_path), "repo_root": str(repo_root)})
            raise FileNotFoundError(msg)
        log.warning("discovery_prompt_missing", extra={"prompt_path": str(prompt_path), "repo_root": str(repo_root)})
        return

    log.info(
        "run_codex_discovery",
        extra={
            "repo_root": str(repo_root),
            "model": model,
            "prompt_path": str(prompt_path),
            "sandbox": sandbox,
            "strict": strict,
        },
    )
    prompt_text = prompt_path.read_text(encoding="utf-8")

    cmd = [
        "codex",
        "exec",
        "-m",
        model,
        "--cd",
        str(repo_root),
        "--sandbox",
        sandbox,
    ]
    if skip_git_check:
        cmd.append("--skip-git-repo-check")
    cmd.append("-")

    codex.run_process(
        cmd,
        cwd=repo_root,
        capture_output=False,
        text=True,
        check=True,
        input_text=prompt_text,
    )
    log.info("codex_discovery_complete", extra={"repo_root": str(repo_root), "model": model})
